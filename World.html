<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>Three.js app</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body onload="loader()">
<script src="js/three.js"></script>
<script src="js/TrackballControls.js"></script>
<script src="js/MTLLoader.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/dat.gui.min.js"></script>

<script type="text/javascript">
    "use strict";
    // Globális változók
    var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
    var aspectRatio = WIDTH / HEIGHT;
    var scene, camera;
    var roomUpperSidesMesh, roomLowerSidesMesh;
    var renderer;
    var ctrl, stats, controls;
    var material;
    var group_r2d2;
    var r2d2_head_mesh, holder;
    var meshLoaded;

    function addStatsObject() {
        stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        document.body.appendChild( stats.domElement );
    }

    var meshController = function () {
        this.rotationBarrel = 0.0;
        this.rotationUpper = 0.0;
        this.positionTank = 0.0;
    };

    function addControlGui( controlObject ) {
        var gui = new dat.GUI( { autoPlace: false } );
        gui.add( controlObject, 'rotationBarrel', -60, 15 ).name( 'Ágyúcső szöge' );
        gui.add( controlObject, 'rotationUpper', -180.0, 180.0 ).name( 'Forgás szöge' );
        gui.add( controlObject, 'positionTank', -400.0, 400.0).name( 'Tank pozíció' );

        gui.domElement.style.position = 'absolute';
        gui.domElement.style.top = '0px';
        gui.domElement.style.right = '0px';
        document.body.appendChild( gui.domElement );
    }


    function loader() {
        var OBJFile = 'assets/models/scene.obj';
        var MTLFile = 'assets/models/scene.mtl';
        new THREE.MTLLoader()
            .load(MTLFile, function (materials) {
                materials.preload();
                new THREE.OBJLoader()
                    .setMaterials(materials)
                    .load(OBJFile, function (object) {
                        meshLoaded = object;
                        console.log(object);

                        object.traverse(function (child) {
                            if (child instanceof THREE.Mesh) {
                                child.scale.set(5, 5, 5);
                                child.rotation.y += 1;
                            }
                        });
                        init();
                    });
            });
    }

    function init() {
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( WIDTH, HEIGHT );
        renderer.setClearColor( 0x1b1e23, 1 );
        document.body.appendChild( renderer.domElement );

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 75, aspectRatio, 0.1, 1000 );
        camera.position.z = 60;
        camera.position.x = -90;
        camera.position.y = 55;
        camera.lookAt( scene.position );

        var axesHelper = new THREE.AxesHelper( 10 );
        scene.add( axesHelper );

        // Kameramozgatás
        controls = new THREE.TrackballControls( camera, renderer.domElement );
        controls.rotateSpeed = 5.0;
        controls.panSpeed = 1.0;

        window.addEventListener( 'resize', handleWindowResize, false );
        //window.addEventListener( 'contextmenu', showRoomSides, false );
        window.addEventListener( 'dblclick', showRoomSides, false );

        var materialFloor = new THREE.MeshBasicMaterial( { color: 0x999999, side: THREE.DoubleSide } );
        var materialWalls = new THREE.MeshBasicMaterial( { color: 0x2c3227, side: THREE.DoubleSide } );
        var materialTransparent =  new THREE.MeshBasicMaterial( { transparent: true, opacity: 0, wireframe: true, side: THREE.DoubleSide} );

        var roomLowerSidesGeometry = new THREE.BoxBufferGeometry( 100, 100, 100);
        var roomLowerSides = [ materialWalls, materialTransparent, materialTransparent,materialFloor,materialTransparent,materialWalls];
        roomLowerSidesMesh = new THREE.Mesh( roomLowerSidesGeometry, roomLowerSides );
        scene.add( roomLowerSidesMesh );

        var roomUpperSidesGeometry = new THREE.BoxBufferGeometry( 100, 100, 100,10,10,10);
        var roomUpperSides = [ materialTransparent, materialFloor, materialFloor,materialTransparent ,materialFloor,materialTransparent];
        roomUpperSidesMesh = new THREE.Mesh( roomUpperSidesGeometry, roomUpperSides );
        scene.add( roomUpperSidesMesh );

        var edgesGeometry = new THREE.EdgesGeometry( roomLowerSidesGeometry ); // or WireframeGeometry( geometry )
        var lineBasicMaterial = new THREE.LineBasicMaterial( { color: 0x0020A0, linewidth: 500 } );
        var boxEdges = new THREE.LineSegments( edgesGeometry, lineBasicMaterial );
        scene.add( boxEdges );

        scene.add( meshLoaded );

        var lightAmbient = new THREE.AmbientLight( 0x202020,1 );
        scene.add( lightAmbient );

        var lightPointLight = new THREE.PointLight( 0xccffcc, 1  );
        lightPointLight.position.set( 0, 10, 0 );
        scene.add( lightPointLight );

        var pLH1 = new THREE.PointLightHelper( lightPointLight, 0.5 );

        scene.add( pLH1 );


        group_r2d2 = new THREE.Group();
        material = new THREE.MeshPhongMaterial( { color: 0x333388, wireframe: false } );

        var r2d2_body_geometry = new THREE.CylinderGeometry( 1, 1, 2 );
        var r2d2_body_mesh = new THREE.Mesh( r2d2_body_geometry, material );
        group_r2d2.add( r2d2_body_mesh );

        var r2d2_head_geometry = new THREE.SphereGeometry( 1, 20, 20 );
        r2d2_head_mesh = new THREE.Mesh( r2d2_head_geometry, material );
        r2d2_head_mesh.position.y = 1;
        group_r2d2.add( r2d2_head_mesh );


        holder = new THREE.Object3D();
        var r2d2_eye_geometry = new THREE.CylinderGeometry( 0.2, 0.2, 0.4 );
        var r2d2_eye_mesh = new THREE.Mesh( r2d2_eye_geometry, material );
        r2d2_eye_mesh.position.z = 1;
        r2d2_eye_mesh.rotation.x += 1.5;
        holder.position.set( 0.0, 0.0, 0.0 );
        holder.add( r2d2_eye_mesh );
        r2d2_head_mesh.add( holder );

        group_r2d2.scale.set( 1, 1, 1 );
        group_r2d2.position.y = 0;
        scene.add( group_r2d2 );

        ctrl = new meshController();
        addControlGui( ctrl );
        addStatsObject();

        controls = new THREE.TrackballControls( camera, renderer.domElement );
        controls.rotateSpeed = 5.0;
        controls.panSpeed = 1.0;

        render();
    }

    function handleWindowResize() {
        // Az ablak átméretezése esetén a kamera vetítési paraméterek újraszámolása
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        renderer.setSize( WIDTH, HEIGHT );
        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();
    }

    function showRoomSides() {
        if (roomUpperSidesMesh.visible) {
            roomUpperSidesMesh.visible = false;
            return
        }
        roomUpperSidesMesh.visible = true;
    }

    function showInfosAboutMe() {
        var about = dom.getChildByName(aboutMe);
        about.visible = false;
    }


    function handleWindowResize() {
        // Az ablak átméretezése esetén a kamera vetítési paraméterek újraszámolása
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        console.log( 'WIDTH=' + WIDTH + '; HEIGHT=' + HEIGHT );
        renderer.setSize( WIDTH, HEIGHT );
        aspectRatio = WIDTH / HEIGHT;
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();
    }

    function handleWindowResizeOrtho() {
        // Az ablak átméretezése esetén a kamera vetítési paraméterek újraszámolása
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        renderer.setSize( WIDTH, HEIGHT );

        camera.left = WIDTH / -2;
        camera.right = WIDTH / 2;
        camera.top = HEIGHT / 2;
        camera.bottom = HEIGHT / -2;
        camera.updateProjectionMatrix();
    }

    var render = function () {
        group_r2d2.position.z = ctrl.positionTank;
        r2d2_head_mesh.rotation.y = ctrl.rotationUpper * Math.PI / 180.0;
        holder.rotation.x = ctrl.rotationBarrel * Math.PI / 180.0;

        controls.update();
        renderer.render(scene, camera);
        stats.update();
        requestAnimationFrame( render );
    };

</script>
</body>
</html>

